import logging

from .hanoi_exception import HanoiException
from .state import State
from .tower import Tower

logging.basicConfig(level = logging.INFO, format = '%(levelname)-10s  %(message)s')


class HanoiGame:
    """
    Main class for management of the data structures and moves of the game.
    """

    def __init__(self, n_discs, n_towers=3):
        """
        Initializes the game with n_discs and n_towers, which defaults to 3.
        At this step, the game can be solved and stored to consult.

        Raises a HanoiException if n_discs is negative or n_towers is less than 3.

        :param n_discs: Number of disks for this game.
        :param n_towers: Number of towers for this game. Default: 3
        """

        # Steps:
        # 1.- Check the parameters (Add the code after this comment)
        if n_discs >= 1:
            self.n_discs = n_discs
        else:
            raise HanoiException("El número de discos debe ser positivo!")
        # 2.- Initialize the structure attributes (Add the code after this comment)
        self.n_discs = n_discs
        self.n_towers = n_towers
        self.states = []
        self.game_states = []
        # 3.- Initialize the towers (Add the code after this comment)
        self.source = Tower()
        for i in range(n_discs, 0, -1):
            self.source.discs.append(i)
        self.target = Tower()
        self.aux = Tower()
        self.towers = [self.source, self.target, self.aux]
        
        #Inicializando los estados con los puntos iniciales
        #self.game_states.append(State(0, 0, None, None, None, self.towers, self.get_n_discs()))
        self.states.append(State(0, 0, None, self.source, self.target, self.towers, self.get_n_discs()))
        # 4.- Solve and store the optimal solution
        self._solve()
        
    def get_state(self, step):
        """
        Returns the state at the requested step in the optimal solution.
        Raises a HanoiException if the step index is negative or bigger than the total of states in the optimal
        solution.

        :param step: The step index in the optimal solution.
        :return: The state at the requested step in the optimal solution.
        """
        return self.states[step]

    def get_n_discs(self):
        """
        Returns the number of disks of this game.

        :return: The number of disks of this game.
        """
        return self.n_discs

    def get_n_towers(self):
        """
        Returns the number of towers of this game.

        :return: The number of towers of this game.
        """
        return self.n_towers

    def get_n_states(self):
        """
        Returns the number of states of the optimal solution. Ideally, it should be the size of the structure used to
        store the optimal solution states.

        :return: The number of states of the optimal solution.
        """
        return len(self.states)

    def move(self, source, target, move_id=None, depth=None):
        """
        Moves a disk from source tower to target tower.
        Raises a HanoiException if source and target are the same or if the move is invalid (the disk moved is bigger
        than the last disk in the target tower, the source tower is empty...)

        :param source: Tower from which a disk is going to be moved.
        :param target: Tower to which a disk is going to be moved.
        :param move_id: Identifier of the movement. Useful as information for the optimal state.
        :param depth: Depth of the recursion call. Useful as information for the optimal state.
        :return: The new state generated by the move.
        """
        try:
            if move_id is not None:
                disk = source.pop_disc()
                #disk = self.towers[source-1].pop_disc()
                target.push_disc(disk)
                #self.towers[target-1].push_disc(disk)
                return State(move_id, depth, disk, source, target, self.towers, self.get_n_discs())
            else:
                if source != target:
                    try:
                        #disk = source.pop_disc()
                        disk = self.towers[source].pop_disc()
                    except AttributeError:
                        HanoiException("No se ha podido extraer el disco por que esta vacío!!")
                    else:
                        if self.towers[target].is_empty() == True:
                            #target.push_disc(disk)
                            self.towers[target].push_disc(disk)
                            #return self.game_states.append(State(len(self.game_states), None, disk, source, target, self.towers, self.get_n_discs()))
                        elif self.towers[target].discs[-1] < disk:
                            self.towers[source].push_disc(disk)
                            raise HanoiException("El movimiento no es valido por que intentas colocar una ficha mayor que la inferior!!")
                        else:
                            self.towers[target].push_disc(disk)
                            #return self.game_states.append(State(len(self.game_states), None, disk, source, target, self.towers, self.get_n_discs()))
                else:
                    raise HanoiException("Origen y destino son la misma torre!")
        except HanoiException as msg:
            print(msg)

    def _solve(self):
        """
        Generates and stores the optimal solution, reinitializing the towers afterwards.
        """
        self._solve_rec(self.n_discs, self.source, self.target, self.aux)
        self.source.discs = self.target.discs.copy()
        self.target.discs.clear()

    def _solve_rec(self, n_discs, source, target, aux, depth=0):
        """
        Recursive call to solve the hanoi game optimally.

        :param n_discs: Number of disks to be moved.
        :param source: Tower from which a disk is going to be moved.
        :param target: Tower to which a disk is going to be moved.
        :param aux: Tower to be used as auxiliary.
        :param depth: Depth of the recursion call. Useful as information for the optimal state.
        """
        if n_discs >= 1:
            self._solve_rec(n_discs-1, source, aux, target, depth+1)
            state = self.move(source, target, self.get_n_states(), depth+1)
            self.states.append(state)
            self._solve_rec(n_discs-1, aux, target, source, depth+1)

    def print_optimal_state(self, step):
        """
        Prints the optimal state at the selected step in the required format.

        :param step: Step index of the optimal solution.
        """
        print(self.get_state(step))

    def print_optimal_solution(self):
        """
        Prints all the states of the optimal solution in the required format.
        """
        for torre in self.states:
            print(torre)

    def is_finished(self):
        """
        Checks if the interactive game is finished, returns True if is finished, False otherwise.

        :return: True if the game is finished, False otherwise.
        """
        if len(self.target.discs) == self.n_discs:
            return True
        else:
            return False

    def get_current_state(self):
        """
        Returns the current state of the game.

        :return: The current state of the game.
        """
        state = State(0, None, None, None, None, self.towers, self.n_discs)
        return str(state)

    def __repr__(self):
        """
        Returns a string with the internal representation of the game. This method can be used to represent the game
        information in a different format than the requested.

        :return: A string with the internal representation of the game.
        """
        #raise NotImplementedError()


    def __str__(self):
        """
        Returns a string with the representation of the current state of the game in the requested format.

        :return: A string with the representation of the current state of the game in the requested format
        """
        return self.get_current_state()

